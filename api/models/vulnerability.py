from api.extensions import db
from datetime import datetime

class Vulnerability(db.Model):
    """
    Master vulnerability definition table.
    Stores unique vulnerabilities with their CVE IDs and descriptions.
    """
    __tablename__ = 'vulnerabilities'

    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(255), nullable=False, index=True)
    description = db.Column(db.Text)
    severity = db.Column(db.String(20), index=True)  # Critical, High, Medium, Low, Info
    cve_id = db.Column(db.String(50), unique=True, index=True)
    cvss_score = db.Column(db.Float)  # CVSS base score (0.0 - 10.0)
    cvss_vector = db.Column(db.String(100))  # CVSS vector string
    remediation = db.Column(db.Text)
    category = db.Column(db.String(100))  # e.g., "SQL Injection", "XSS", "Misconfiguration"
    references = db.Column(db.Text)  # JSON or newline-separated URLs
    
    # CVE Enrichment Fields
    cve_ids = db.Column(db.Text)  # JSON list of all CVE IDs
    cve_published_date = db.Column(db.DateTime)  # CVE publication date
    
    # Exploit Availability
    has_exploit = db.Column(db.Boolean, default=False, index=True)
    exploit_count = db.Column(db.Integer, default=0)
    exploit_sources = db.Column(db.Text)  # JSON: {'searchsploit': 2, 'metasploit': 1}
    
    # Nuclei Templates
    nuclei_templates = db.Column(db.Text)  # JSON list of template paths
    
    # Enrichment Metadata
    enriched_at = db.Column(db.DateTime)
    enrichment_source = db.Column(db.String(50))  # 'nvd', 'manual', etc.
    
    created_at = db.Column(db.DateTime, default=datetime.utcnow, index=True)
    updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    @staticmethod
    def calculate_severity_from_cvss(cvss_score):
        """
        Calculate severity category from CVSS score.
        Based on CVSS v3.1 severity ratings.
        """
        if cvss_score is None:
            return 'Info'
        elif cvss_score >= 9.0:
            return 'Critical'
        elif cvss_score >= 7.0:
            return 'High'
        elif cvss_score >= 4.0:
            return 'Medium'
        elif cvss_score > 0.0:
            return 'Low'
        else:
            return 'Info'

# Association table for VulnerabilityInstance assignments
vulnerability_assignments = db.Table('vulnerability_assignments',
    db.Column('user_id', db.Integer, db.ForeignKey('users.id'), primary_key=True),
    db.Column('vulnerability_instance_id', db.Integer, db.ForeignKey('vulnerability_instances.id'), primary_key=True),
    db.Column('assigned_at', db.DateTime, default=datetime.utcnow)
)

class VulnerabilityInstance(db.Model):
    """
    Specific instance of a vulnerability found on a target during a scan.
    Links vulnerability definitions to specific targets and scans.
    """
    __tablename__ = 'vulnerability_instances'

    id = db.Column(db.Integer, primary_key=True)
    vulnerability_id = db.Column(db.Integer, db.ForeignKey('vulnerabilities.id'), nullable=False, index=True)
    scan_id = db.Column(db.Integer, db.ForeignKey('scans.id'), nullable=False, index=True)
    target_id = db.Column(db.Integer, db.ForeignKey('targets.id'), nullable=False, index=True)
    
    # Status tracking
    status = db.Column(db.String(20), default='open', index=True)  # open, fixed, false_positive, accepted_risk
    
    # Location details
    port = db.Column(db.String(20))  # Port number or range
    protocol = db.Column(db.String(20))  # tcp, udp, etc.
    service = db.Column(db.String(100))  # Service name (e.g., "http", "ssh")
    
    # Additional context
    evidence = db.Column(db.Text)  # Proof of vulnerability (output, payload, etc.)
    false_positive_reason = db.Column(db.Text)  # Reason if marked as false positive
    
    # Timestamps
    detected_at = db.Column(db.DateTime, default=datetime.utcnow, index=True)
    fixed_at = db.Column(db.DateTime)
    verified_at = db.Column(db.DateTime)
    
    # Relationships
    vulnerability = db.relationship('Vulnerability', backref='instances')
    target = db.relationship('Target', backref='vulnerabilities')
    scan = db.relationship('Scan', backref=db.backref('vulnerabilities', cascade='all, delete-orphan'))
    
    # Assignments
    assigned_users = db.relationship('User', secondary=vulnerability_assignments, 
                                     backref=db.backref('assigned_vulnerabilities', lazy='dynamic'))
    
    def to_dict(self):
        """Convert instance to dictionary for API responses"""
        return {
            'id': self.id,
            'vulnerability_id': self.vulnerability_id,
            'vulnerability_name': self.vulnerability.name if self.vulnerability else None,
            'severity': self.vulnerability.severity if self.vulnerability else None,
            'cvss_score': self.vulnerability.cvss_score if self.vulnerability else None,
            'target_id': self.target_id,
            'target_name': self.target.name if self.target else None,
            'scan_id': self.scan_id,
            'status': self.status,
            'port': self.port,
            'protocol': self.protocol,
            'service': self.service,
            'detected_at': self.detected_at.isoformat() if self.detected_at else None,
            'fixed_at': self.fixed_at.isoformat() if self.fixed_at else None,
            'assigned_users': [{'id': u.id, 'username': u.username} for u in self.assigned_users]
        }
